\chapter{XCLua Inline Assembly Tutorial }
\hypertarget{md__a_s_m___t_u_t_o_r_i_a_l}{}\label{md__a_s_m___t_u_t_o_r_i_a_l}\index{XCLua Inline Assembly Tutorial@{XCLua Inline Assembly Tutorial}}
\label{md__a_s_m___t_u_t_o_r_i_a_l_autotoc_md0}%
\Hypertarget{md__a_s_m___t_u_t_o_r_i_a_l_autotoc_md0}%


XCLua provides a powerful inline assembly feature that allows you to inject raw Lua virtual machine instructions directly into your Lua code. This is useful for performance optimization, low-\/level manipulation, or implementing features not expressible in standard Lua.\hypertarget{md__a_s_m___t_u_t_o_r_i_a_l_autotoc_md1}{}\doxysection{\texorpdfstring{Basic Syntax}{Basic Syntax}}\label{md__a_s_m___t_u_t_o_r_i_a_l_autotoc_md1}
Inline assembly is written inside an {\ttfamily asm(...)} block. Instructions are separated by semicolons ({\ttfamily ;}).


\begin{DoxyCode}{0}
\DoxyCodeLine{asm(}
\DoxyCodeLine{\ \ \ \ LOADI\ R0\ 100;}
\DoxyCodeLine{\ \ \ \ RETURN1\ R0;}
\DoxyCodeLine{)}

\end{DoxyCode}
\hypertarget{md__a_s_m___t_u_t_o_r_i_a_l_autotoc_md2}{}\doxysection{\texorpdfstring{Operands and Modifiers}{Operands and Modifiers}}\label{md__a_s_m___t_u_t_o_r_i_a_l_autotoc_md2}
The assembler supports various modifiers to make it easier to work with Lua\textquotesingle{}s internal structures.\hypertarget{md__a_s_m___t_u_t_o_r_i_a_l_autotoc_md3}{}\doxysubsection{\texorpdfstring{Registers}{Registers}}\label{md__a_s_m___t_u_t_o_r_i_a_l_autotoc_md3}

\begin{DoxyItemize}
\item {\bfseries{Raw Registers}}:\+ {\ttfamily R0}, {\ttfamily R1}, {\ttfamily R2}, ... (Direct register access)
\item {\bfseries{Local Variables}}:\+ {\ttfamily \$varname} (Resolves to the register assigned to the local variable {\ttfamily varname})
\item {\bfseries{Allocated Registers}}:\+ See {\ttfamily newreg} below.
\end{DoxyItemize}\hypertarget{md__a_s_m___t_u_t_o_r_i_a_l_autotoc_md4}{}\doxysubsection{\texorpdfstring{Constants}{Constants}}\label{md__a_s_m___t_u_t_o_r_i_a_l_autotoc_md4}

\begin{DoxyItemize}
\item {\bfseries{Integers}}:\+ {\ttfamily \#123} (Used for immediate operands like {\ttfamily LOADI})
\item {\bfseries{Floats}}:\+ {\ttfamily \#3.\+14} (Used for {\ttfamily LOADF})
\item {\bfseries{Strings}}:\+ {\ttfamily \#"{}string"{}} (Adds string to constant table and returns index)
\item {\bfseries{Add to Constant Pool}}:\+
\begin{DoxyItemize}
\item {\ttfamily \#K 123}:\+ Adds integer 123 to constant pool and returns index.
\item {\ttfamily \#KF 3.\+14}:\+ Adds float 3.\+14 to constant pool and returns index.
\end{DoxyItemize}
\end{DoxyItemize}\hypertarget{md__a_s_m___t_u_t_o_r_i_a_l_autotoc_md5}{}\doxysubsection{\texorpdfstring{Upvalues}{Upvalues}}\label{md__a_s_m___t_u_t_o_r_i_a_l_autotoc_md5}

\begin{DoxyItemize}
\item {\bfseries{Upvalue Index}}:\+ {\ttfamily \texorpdfstring{$^\wedge$}{\string^}varname} (Resolves to the upvalue index of {\ttfamily varname})
\end{DoxyItemize}\hypertarget{md__a_s_m___t_u_t_o_r_i_a_l_autotoc_md6}{}\doxysubsection{\texorpdfstring{Labels and Jumps}{Labels and Jumps}}\label{md__a_s_m___t_u_t_o_r_i_a_l_autotoc_md6}

\begin{DoxyItemize}
\item {\bfseries{Define Label}}:\+ {\ttfamily :\+label\+\_\+name}
\item {\bfseries{Reference Label}}:\+ {\ttfamily @label\+\_\+name} (Returns PC of label)
\item {\bfseries{Current PC}}:\+ {\ttfamily @}
\end{DoxyItemize}\hypertarget{md__a_s_m___t_u_t_o_r_i_a_l_autotoc_md7}{}\doxysubsection{\texorpdfstring{Special Values}{Special Values}}\label{md__a_s_m___t_u_t_o_r_i_a_l_autotoc_md7}

\begin{DoxyItemize}
\item {\ttfamily !freereg}:\+ Current top of the stack (first free register).
\item {\ttfamily !pc}:\+ Current instruction pointer.
\item {\ttfamily !nk}:\+ Number of constants.
\end{DoxyItemize}\hypertarget{md__a_s_m___t_u_t_o_r_i_a_l_autotoc_md8}{}\doxysection{\texorpdfstring{Directives and Pseudo-\/instructions}{Directives and Pseudo-\/instructions}}\label{md__a_s_m___t_u_t_o_r_i_a_l_autotoc_md8}
\hypertarget{md__a_s_m___t_u_t_o_r_i_a_l_autotoc_md9}{}\doxysubsection{\texorpdfstring{{\ttfamily newreg name}}{{\ttfamily newreg name}}}\label{md__a_s_m___t_u_t_o_r_i_a_l_autotoc_md9}
Allocates a new register on the stack and defines {\ttfamily name} as an alias for it. This ensures the compiler knows the register is in use.


\begin{DoxyCode}{0}
\DoxyCodeLine{asm(}
\DoxyCodeLine{\ \ \ \ newreg\ temp;}
\DoxyCodeLine{\ \ \ \ LOADI\ temp\ 42;}
\DoxyCodeLine{)}

\end{DoxyCode}
\hypertarget{md__a_s_m___t_u_t_o_r_i_a_l_autotoc_md10}{}\doxysubsection{\texorpdfstring{{\ttfamily getglobal reg "{}name"{}}}{{\ttfamily getglobal reg "{}name"{}}}}\label{md__a_s_m___t_u_t_o_r_i_a_l_autotoc_md10}
Loads a global variable into a register.


\begin{DoxyCode}{0}
\DoxyCodeLine{asm(}
\DoxyCodeLine{\ \ \ \ newreg\ r;}
\DoxyCodeLine{\ \ \ \ getglobal\ r\ "{}print"{};}
\DoxyCodeLine{)}

\end{DoxyCode}
\hypertarget{md__a_s_m___t_u_t_o_r_i_a_l_autotoc_md11}{}\doxysubsection{\texorpdfstring{{\ttfamily setglobal reg "{}name"{}}}{{\ttfamily setglobal reg "{}name"{}}}}\label{md__a_s_m___t_u_t_o_r_i_a_l_autotoc_md11}
Sets a global variable from a register.


\begin{DoxyCode}{0}
\DoxyCodeLine{asm(}
\DoxyCodeLine{\ \ \ \ newreg\ val;}
\DoxyCodeLine{\ \ \ \ LOADI\ val\ 100;}
\DoxyCodeLine{\ \ \ \ setglobal\ val\ "{}my\_global"{};}
\DoxyCodeLine{)}

\end{DoxyCode}
\hypertarget{md__a_s_m___t_u_t_o_r_i_a_l_autotoc_md12}{}\doxysubsection{\texorpdfstring{{\ttfamily def name value}}{{\ttfamily def name value}}}\label{md__a_s_m___t_u_t_o_r_i_a_l_autotoc_md12}
Defines a local assembly constant.


\begin{DoxyCode}{0}
\DoxyCodeLine{asm(}
\DoxyCodeLine{\ \ \ \ def\ MY\_CONST\ 10;}
\DoxyCodeLine{\ \ \ \ LOADI\ R0\ MY\_CONST;}
\DoxyCodeLine{)}

\end{DoxyCode}
\hypertarget{md__a_s_m___t_u_t_o_r_i_a_l_autotoc_md13}{}\doxysubsection{\texorpdfstring{{\ttfamily jmpx @label} /\+ {\ttfamily JMP @label}}{{\ttfamily jmpx @label} /\+ {\ttfamily JMP @label}}}\label{md__a_s_m___t_u_t_o_r_i_a_l_autotoc_md13}
Jumps to a label. {\ttfamily jmpx} is a helper that explicitly calculates relative offsets, but standard {\ttfamily JMP} also supports {\ttfamily @label} correctly.


\begin{DoxyCode}{0}
\DoxyCodeLine{asm(}
\DoxyCodeLine{\ \ \ \ :loop;}
\DoxyCodeLine{\ \ \ \ ...}
\DoxyCodeLine{\ \ \ \ JMP\ @loop;}
\DoxyCodeLine{)}

\end{DoxyCode}
\hypertarget{md__a_s_m___t_u_t_o_r_i_a_l_autotoc_md14}{}\doxysubsection{\texorpdfstring{Debugging}{Debugging}}\label{md__a_s_m___t_u_t_o_r_i_a_l_autotoc_md14}

\begin{DoxyItemize}
\item {\ttfamily \+\_\+print "{}msg"{} val}:\+ Prints a message and optional value during compilation.
\item {\ttfamily \+\_\+assert cond}:\+ Asserts a condition at compile time.
\end{DoxyItemize}\hypertarget{md__a_s_m___t_u_t_o_r_i_a_l_autotoc_md15}{}\doxysection{\texorpdfstring{Examples}{Examples}}\label{md__a_s_m___t_u_t_o_r_i_a_l_autotoc_md15}
\hypertarget{md__a_s_m___t_u_t_o_r_i_a_l_autotoc_md16}{}\doxysubsection{\texorpdfstring{1. Simple Math}{1. Simple Math}}\label{md__a_s_m___t_u_t_o_r_i_a_l_autotoc_md16}

\begin{DoxyCode}{0}
\DoxyCodeLine{local\ result}
\DoxyCodeLine{asm(}
\DoxyCodeLine{\ \ \ \ newreg\ a;}
\DoxyCodeLine{\ \ \ \ newreg\ b;}
\DoxyCodeLine{\ \ \ \ LOADI\ a\ 10;}
\DoxyCodeLine{\ \ \ \ LOADI\ b\ 20;}
\DoxyCodeLine{\ \ \ \ ADD\ a\ a\ b;}
\DoxyCodeLine{\ \ \ \ MOVE\ \$result\ a;}
\DoxyCodeLine{)}
\DoxyCodeLine{print(result)\ -\/-\/\ 30}

\end{DoxyCode}
\hypertarget{md__a_s_m___t_u_t_o_r_i_a_l_autotoc_md17}{}\doxysubsection{\texorpdfstring{2. Global Function Call}{2. Global Function Call}}\label{md__a_s_m___t_u_t_o_r_i_a_l_autotoc_md17}

\begin{DoxyCode}{0}
\DoxyCodeLine{asm(}
\DoxyCodeLine{\ \ \ \ newreg\ func;}
\DoxyCodeLine{\ \ \ \ newreg\ arg;}
\DoxyCodeLine{\ \ \ \ getglobal\ func\ "{}print"{};}
\DoxyCodeLine{\ \ \ \ LOADK\ arg\ \#"{}Hello\ from\ ASM!"{};}
\DoxyCodeLine{\ \ \ \ CALL\ func\ 2\ 1;\ -\/-\/\ 2\ args\ (func\ +\ arg),\ 1\ result\ (void)}
\DoxyCodeLine{)}

\end{DoxyCode}
\hypertarget{md__a_s_m___t_u_t_o_r_i_a_l_autotoc_md18}{}\doxysubsection{\texorpdfstring{3. Custom Loop}{3. Custom Loop}}\label{md__a_s_m___t_u_t_o_r_i_a_l_autotoc_md18}

\begin{DoxyCode}{0}
\DoxyCodeLine{local\ sum\ =\ 0}
\DoxyCodeLine{asm(}
\DoxyCodeLine{\ \ \ \ newreg\ cnt;}
\DoxyCodeLine{\ \ \ \ newreg\ acc;}
\DoxyCodeLine{\ \ \ \ LOADI\ cnt\ 5;}
\DoxyCodeLine{\ \ \ \ LOADI\ acc\ 0;}
\DoxyCodeLine{}
\DoxyCodeLine{\ \ \ \ :loop;}
\DoxyCodeLine{\ \ \ \ ADD\ acc\ acc\ cnt;}
\DoxyCodeLine{\ \ \ \ SUBK\ cnt\ cnt\ \#K\ 1;\ -\/-\/\ Subtract\ constant\ 1}
\DoxyCodeLine{}
\DoxyCodeLine{\ \ \ \ -\/-\/\ Check\ if\ cnt\ >\ 0}
\DoxyCodeLine{\ \ \ \ -\/-\/\ LT\ A\ B\ k:\ if\ (R[A]\ <\ R[B])\ \string~=\ k\ then\ pc++}
\DoxyCodeLine{\ \ \ \ -\/-\/\ We\ want:\ if\ cnt\ >\ 0\ goto\ loop}
\DoxyCodeLine{\ \ \ \ -\/-\/\ Use\ LEI\ (Less\ Equal\ Immediate)?\ Or\ just\ check\ sign?}
\DoxyCodeLine{\ \ \ \ -\/-\/\ Let's\ use\ simple\ logic:\ if\ cnt\ ==\ 0\ then\ break}
\DoxyCodeLine{\ \ \ \ EQI\ cnt\ 0\ 0;\ -\/-\/\ if\ cnt\ ==\ 0\ then\ skip\ next\ (JMP)}
\DoxyCodeLine{\ \ \ \ JMP\ @loop;}
\DoxyCodeLine{}
\DoxyCodeLine{\ \ \ \ MOVE\ \$sum\ acc;}
\DoxyCodeLine{)}
\DoxyCodeLine{print(sum)\ -\/-\/\ 15}

\end{DoxyCode}
 