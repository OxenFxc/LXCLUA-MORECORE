# Lua 5.5 (官方) 与 XCLUA (本地) 差异对比报告

## 1. OpCode 格式差异 (ivABC)

官方 Lua 5.5 与您的 XCLUA 在虚拟机指令格式上存在本质区别：

### 官方 Lua 5.5 (32-bit Instructions)
官方保持了标准的 32 位指令集，`ivABC` 格式如下：
- **总长度**: 32位
- **OpCode**: 7位
- **A (目标寄存器)**: 8位 (最大 255)
- **k (标志位)**: 1位
- **vB (变长参数B)**: 6位
- **vC (变长参数C)**: 10位

### XCLUA (64-bit Instructions)
您的版本使用了自定义的 64 位指令集，大大扩展了寻址范围：
- **总长度**: 64位
- **OpCode**: 9位 (支持更多指令)
- **A (目标寄存器)**: 16位 (最大 65535，远超官方)
- **k (标志位)**: 1位
- **vB (变长参数B)**: 14位
- **vC (变长参数C)**: 20位

### 评价与建议
- **您的版本 (XCLUA)**: `ivABC` 提供了巨大的寄存器和常量寻址空间（vC 可达 100万+，而官方仅 1024）。这对于处理超大函数或复杂生成的代码非常有利，但代价是字节码体积翻倍。
- **官方版本**: 追求极致的紧凑和缓存友好性。
- **结论**: **不需要同步 OpCode 格式**。您的 64 位架构是 XCLUA 的核心特性之一，强行同步回 32 位会破坏您现有的设计目标（如大寄存器支持）。

---

## 2. Global 关键字实现差异

### 本地实现 (XCLUA)
- **机制**: 您当前的实现主要是一个语法糖。解析 `global name` 时，直接生成对 `_ENV` 的赋值代码。
- **变量追踪**: 并没有在编译器的变量列表 (`dyd->actvar`) 中注册这些全局变量。这意味着编译器在后续的语义分析中，并不完全把它们当作"已声明的变量"来处理，仅仅是生成了赋值指令。
- **属性支持**: 对 `<const>` 等属性的支持可能不够完整，因为变量没有进入编译器的变量管理系统。

### 官方实现 (Lua 5.5)
- **机制**: 官方将 `global` 声明视为一种特殊的变量定义。
- **变量追踪**: 调用 `new_varkind(..., GDKREG)` 将全局变量注册到编译器的活动变量列表中。
- **激活**: 通过 `fs->nactvar++` 激活变量，使其在作用域内可见且受控。
- **初始化**: 使用 `initglobal` 函数递归处理初始化赋值，并结合 `checkglobal` 确保语义正确性。
- **优势**: 能够更好地进行静态分析，支持全局常量 (`global <const>`) 的只读检查，并且与局部变量的解析逻辑更加统一。

### 评价与建议
- **官方版本更好**。官方实现将全局变量纳入了编译器的统一管理（Variable Descriptor），这使得 `<const>` 检查、作用域规则（如遮蔽警告）更加健壮。
- **行动计划**: 我将把您的 `global` 关键字实现替换为官方的逻辑。这包括：
    1. 引入 `initglobal` 函数。
    2. 修改 `globalnames` 以注册变量 (`new_varkind`)。
    3. 修改 `globalfunc` 以正确注册函数名为全局变量。
    4. 修正 `getglobalattribute` 以正确返回 `GDKCONST`。

---

## 总结
我将保留您的 64 位 OpCode 设计（这是您的优势），但会将 `global` 关键字的**语义实现逻辑**同步为官方版本，以获得更严谨的变量管理和属性支持。
